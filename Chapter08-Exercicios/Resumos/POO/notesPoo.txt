Aula 00 - Programação Orientada a Objetos -

Caso não existisse a poo, tudo seria resolvido através de funções e variáveis "soltas".
O problema gerado por isso: Gerir os dados de um carrinho de compra.

----------------------------------------------------------------------------------------------------------
// DADOS
let itemsDoCarrinho = [];
let subtotalDoCarrinho = 0.0;

// COMPORTAMENTOS (FUNÇÕES)
function adicionar(item) {
    itemsDoCarrinho.push(item);
    // ... lógica para recalcular o subtotal, etc.
}

function remover(indice) {
    itemsDoCarrinho.splice(indice, 1);
    // ... lógica para recalcular...
}
----------------------------------------------------------------------------------------------------------

Análise: Funciona? Sim. Mas é frágil e desorganizado. Os dados (itemsDoCarrinho) estão completamente separados das funções (adicionar) que operam neles. Se quiséssemos ter um segundo carrinho, seria um pesadelo.

Conceito Aprendido: Precisamos de uma forma de agrupar dados e comportamentos que estão relacionados.

__________________________________________________________________________________________________________

Aula 01 - A primeira solução - O Objeto Literal

Um objeto é exatamente isso: um "pacote" que agrupa propriedades (dados) e métodos (comportamentos).

----------------------------------------------------------------------------------------------------------
// OBJETO 
const carrinho = {
    items: [],
    subtotal: 0.0,
    adicionarItem(item) {
        // ...
    }
};
----------------------------------------------------------------------------------------------------------

Análise: Muito melhor! Agora, os dados (items, subtotal) e as funções que os manipulam (adicionarItem) vivem juntos no mesmo "pacote". Isso é Encapsulamento na sua forma mais básica.

Conceito Aprendido: Objetos organizam nosso código agrupando dados e funções relacionadas.

__________________________________________________________________________________________________________

Aula 02 - O Novo Problema - Como Criar Vários Carrinhos?

A nossa solução com objeto literal é ótima, mas só temos um carrinho. E se a Ana e o João estivessem a fazer compras ao mesmo tempo no nosso site? Precisaríamos de dois carrinhos independentes.

A Tentativa Ruim: Copiar e colar o objeto.

----------------------------------------------------------------------------------------------------------
const carrinhoDaAna = {
    items: [],
    subtotal: 0.0,
    adicionarItem(item) {
        // ...
    }
};

const carrinhoDoJoao = {
    items: [],
    subtotal: 0.0,
    adicionarItem(item) {
        // ...
    }
};
----------------------------------------------------------------------------------------------------------

Análise: Isto é terrível. Se encontrarmos um erro no método removerItem, teremos que o corrigir em todos os carrinhos que copiámos. Violamos o princípio "Don't Repeat Yourself" (DRY).

Conceito Aprendido: Precisamos de um molde ou uma planta para criar carrinhos, em vez de construir cada um do zero.

__________________________________________________________________________________________________________

Aula 03 - A Solução Elegante - A Classe (A Planta)

A Classe é essa planta. É um modelo que define como todos os carrinhos devem ser. Não é um carrinho de verdade, mas sim a ideia de um carrinho.

----------------------------------------------------------------------------------------------------------
class Carrinho {
    // Aqui dentro vamos definir a estrutura e os comportamentos
    // que TODOS os carrinhos terão.
}
----------------------------------------------------------------------------------------------------------

Conceito Aprendido: Uma Classe é um molde para criar objetos.

__________________________________________________________________________________________________________

Aula 4 - Construindo a Partir da Planta (O constructor e o new)

Ok, temos a planta. Como construímos um carrinho de verdade?
Usamos o constructor (o processo de construção) e a palavra new (a ordem para construir).

O constructor é um método especial que é executado uma vez para inicializar cada novo objeto.

----------------------------------------------------------------------------------------------------------
class Carrinho {
  constructor() {
    // 'this' aqui significa "o objeto novinho em folha que está a ser construído".
    // Estamos a dizer: "Todo o novo carrinho deve começar com uma
    // lista de items vazia e um subtotal de zero."
    this.items = [];
    this.subtotal = 0.0;
  }
}

// A Mágica Acontece Aqui:
const carrinhoDaAna = new Carrinho(); // Constrói um carrinho para a Ana.
const carrinhoDoJoao = new Carrinho(); // Constrói OUTRO carrinho para o João.

carrinhoDaAna.items.push("Maçã");
console.log(carrinhoDaAna.items);  // Saída: [ 'Maçã' ]
console.log(carrinhoDoJoao.items); // Saída: [] (O carrinho do João está independente e vazio!)
----------------------------------------------------------------------------------------------------------

Conceitos Aprendidos:

- O constructor inicializa o estado de um novo objeto.

- A palavra new cria uma instância (um objeto real) a partir de uma classe.

- Cada instância é independente da outra.

__________________________________________________________________________________________________________

Aula 5: Dando Habilidades aos Carrinhos (Métodos e o this)

Agora que os nossos carrinhos têm dados (items, subtotal), eles precisam de ter habilidades (métodos). Vamos adicionar os métodos à nossa planta.

----------------------------------------------------------------------------------------------------------
class Carrinho {
  constructor() {
    this.items = [];
    this.subtotal = 0.0;
  }

  // Adicionando um método à planta
  adicionarItem(item) {
    // 'this' aqui é CRUCIAL. Ele diz: "adicione à lista de items
    // DESTA instância específica que me chamou".
    this.items.push(item);
    // (e a outra lógica...)
  }
}

const carrinhoDaAna = new Carrinho();
carrinhoDaAna.adicionarItem({ nome: "Leite", preco: 5.0 }); // 'this' aqui dentro é 'carrinhoDaAna'

const carrinhoDoJoao = new Carrinho();
carrinhoDoJoao.adicionarItem({ nome: "Pão", preco: 2.0 }); // 'this' aqui dentro é 'carrinhoDoJoao'
----------------------------------------------------------------------------------------------------------

Conceito Aprendido: Métodos são definidos na classe para dar comportamento aos objetos. O this garante que o método atue apenas nos dados da instância que o chamou.

__________________________________________________________________________________________________________

Aula 6: O Grande Final - A Nossa Classe Carrinho Completa

Agora, juntamos tudo. Pegamos na nossa planta Carrinho, no nosso constructor e em todos os métodos do exercício original.

O resultado é a solução final e correta que vimos antes:

----------------------------------------------------------------------------------------------------------
class Carrinho {
  constructor() {
    this.items = [];
    this.subtotal = 0.0;
  }

  adicionarItem(item) { /* ...código completo... */ }
  removerItem(indice) { /* ...código completo... */ }
  recalcularSubtotal() { /* ...código completo... */ }
  mostrarResumo() { /* ...código completo... */ }
}

// E a utilização é a criação de uma instância e a chamada dos seus métodos.
const meuCarrinho = new Carrinho();
meuCarrinho.adicionarItem({ nome: "Headphone", preco: 249.9 });
meuCarrinho.mostrarResumo();
----------------------------------------------------------------------------------------------------------

Você acaba de percorrer o caminho completo do pensamento orientado a objetos:

Identificou a necessidade de agrupar dados e funções (Objeto).

Identificou a necessidade de reutilização e padronização (Classe).

Aprendeu a criar objetos independentes a partir do molde (new e constructor).

Aprendeu a dar comportamento a esses objetos de forma que eles manipulem os seus próprios dados (Métodos e this).

__________________________________________________________________________________________________________